/* Generated By:JavaCC: Do not edit this line. QuantumAssembly.java */
import java.io.*;
import java.util.*;
class QuantumAssembly implements QuantumAssemblyConstants {

    public static void main(String[] args) throws ParseException, FileNotFoundException, IOException{

        try {

                        //valida la sintaxis
            QuantumAssembly quantum = new QuantumAssembly (System.in);
                        quantum.Start();

                        //leer el lenguaje
                        ArrayList commands = new ArrayList();
                        int counter = 0;
                        String cadena;
                        FileReader f = new FileReader("Z.txt");
                        BufferedReader b = new BufferedReader(f);
                        String[] parts;
                        File file = new File("Write.java");
                        Writer writer = new BufferedWriter(new FileWriter(file));
                        //writer.write("import Quantum.*;"); //Import Quantum
                        writer.write("import java.util.*;\u005cn"); //import Java Util
                        writer.write("public class Main {\u005cn"); //Clase Main
                        writer.write("public static void main(String[] args) {\u005cn"); //Abrir main
                        writer.write("ArrayList<?> hadamardMatrix = QuantumCompilerMethods.createHadamardMatrix();\u005cn");
                        writer.write("DAMM");
                        writer.write("ArrayList<?> controlledNotMatrix = QuantumCompilerMethods.createControlledNotMatrix();\u005cn");
                        writer.write("ArrayList<?> identityMatrix = QuantumCompilerMethods.createIdentityMatrix();\u005cn");
                        writer.write("HashMap<String,ArrayList<String>> undoing = new HashMap();\u005cn");

                        writer.write("HashMap<ArrayList<String>, ComplexNumber[][]> undoingMatrix = new HashMap();\u005cn");
                        while((cadena = b.readLine())!=null) {

                                //mirar cada linea del lenguaje
                                System.out.println(counter+". " + cadena);
                                parts = cadena.split(" ");
                                String codeLine;
                                if(parts[0].equals("INITIALIZE")){
                                        String name = parts[1];
                                        writer.write("ArrayList<ComplexNumber[]> "+name+" = new ArrayList();\u005cn");
                                        String register = parts[2].substring(1,parts[2].length()-1);
                                        writer.write(name+" = QuantumCompilerMethods.createQubitRegister(\u005c""+register+"\u005c");\u005cn");


                                }
                                else if(parts[0].equals("SELECT")){
                                        String name = parts[1];
                                        String registerToGetName = parts[2];
                                        String[] registerRange = parts[3].split(":");
                                        writer.write("ArrayList<ComplexNumber[]> "+name+" = new ArrayList("+registerToGetName+".subList("+registerRange[0]+","+registerRange[1]+"));\u005cn");

                                }
                                else if(parts[0].equals("APPLY")){
                                        String gate = parts[1];
                                        String name = parts[2];

                                        if(gate.equals("H")){
                                                String variableName = null;
                                                if (variableName == null){
                                                        writer.write("ArrayList<ComplexNumber[]> apply"+name+gate+" = QuantumCompilerMethods.quantumApply((ComplexNumber[][]) hadamardMatrix.get(0),"+name +");\u005cn");
                                                        /*writer.write("ArrayList<String> hundoingarraylist = new ArrayList();\n");
							writer.write("hundoingarraylist.add(H);\n");
							writer.write("undoing.put(tensor"+name+gate+",hundoingarraylist);\n");
							writer.write("undoingMatrix.put(hundoingarraylist,tensor"+name+gate+");\n");*/
                                                }
                                                else{
                                                        writer.write("apply"+name+gate+" = QuantumCompilerMethods.quantumApply((ComplexNumber[][]) hadamardMatrix.get(0),"+name +");\u005cn");
                                                        /*writer.write("hundoingarraylist.add(H);\n");
							writer.write("undoing.put(tensor"+name+gate+",hundoingarraylist);\n");
							writer.write("undoingMatrix.put(hundoingarraylist,tensor"+name+gate+");\n");*/
                                                }
                                        }

                                        else if(gate.equals("CNOT")){
                                                String variableName = null;
                                                if (variableName == null){
                                                        writer.write("ArrayList<ComplexNumber[]>  apply"+name+gate+" = QuantumCompilerMethods.quantumApply((ComplexNumber[][]) controlledNotMatrix.get(0),"+name +");\u005cn");
                                                        /*writer.write("ArrayList<String> cnotundoingarraylist = new ArrayList();\n");
							writer.write("cnotundoingarraylist.add(CNOT);\n");
							writer.write("undoing.put(tensor"+name+gate+",cnotundoingarraylist);\n");
							writer.write("undoingMatrix.put(cnotundoingarraylist,tensor"+name+gate+");\n");*/
                                                }
                                                else{
                                                        writer.write("apply"+name+gate+" = QuantumCompilerMethods.quantumApply((ComplexNumber[][]) controlledNotMatrix.get(0),"+name +");\u005cn");
                                                        /*writer.write("cnotundoingarraylist.add(CNOT);\n");
							writer.write("undoing.put(tensor"+name+gate+",cnotundoingarraylist);\n");
							writer.write("undoingMatrix.put(cnotundoingarraylist,tensor"+name+gate+");\n");*/
                                                }
                                        }
                                }
                                else if(parts[0].equals("TENSOR")){
                                        String varName = parts[1];
                                        String firtVar = parts[2];
                                        String secondVar = parts[3];
                                        String variableName = null;
                                        if(firtVar.equals("Hada") && secondVar.equals("Hada")){
                                                firtVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                        }
                                        else if (firtVar.equals("Cnot") && secondVar.equals("Cnot")){
                                                firtVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                        }
                                        else if (firtVar.equals("Iden") && secondVar.equals("Iden")){
                                                firtVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Hada") && secondVar.equals("Cnot")){
                                                firtVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Cnot") && secondVar.equals("Hada")){
                                                firtVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Hada") && secondVar.equals("Iden")){
                                                firtVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Iden") && secondVar.equals("Hada")){
                                                firtVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) hadamardMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Iden") && secondVar.equals("Cnot")){
                                                firtVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                        }
                                        else if(firtVar.equals("Cnot") && secondVar.equals("Iden")){
                                                firtVar = "(ComplexNumber[][]) controlledNotMatrix.get(0)";
                                                secondVar = "(ComplexNumber[][]) identityMatrix.get(0)";
                                        }
                                        else{
                                                if(secondVar.equals("Hada")){
                                                        System.out.println("Entor1");
                                                        secondVar = "hadamardMatrix";
                                                }
                                                if(firtVar.equals("Cnot")){
                                                        firtVar = "controlledNotMatrix";
                                                }
                                                if(secondVar.equals("Cnot")){
                                                        secondVar = "controlledNotMatrix)";
                                                }
                                                if(firtVar.equals("Iden")){
                                                        firtVar = "identityMatrix";
                                                }
                                                if(secondVar.equals("Iden")){
                                                        secondVar = "identityMatrix";
                                                }
                                        }
                                        if (variableName == null){
                                                        writer.write("ArrayList<?> "+varName+" = QuantumCompilerMethods.tensorProduct("+firtVar+","+secondVar +");\u005cn");
                                                }
                                        else{
                                                        writer.write(varName+" = QuantumCompilerMethods.tensorProduct("+firtVar+","+secondVar +");\u005cn");
                                        }
                                }
                                else if(parts[0].equals("CONCAT")){
                                        String varName = parts[1];
                                        String firtVar = parts[2];
                                        String secondVar = parts[3];
                                        String variableName = null;
                                        if (variableName == null){
                                                writer.write("ArrayList<ComplexNumber[]> "+varName+" = new ArrayList<>("+firtVar+");\u005cn");
                                                writer.write(varName+".add("+secondVar+");\u005cn");
                                        }
                                        else{
                                                writer.write(varName+".add("+firtVar+");\u005cn");
                                                writer.write(varName+".add("+secondVar+");\u005cn");
                                        }
                                }
                                else if(parts[0].equals("INVERSE")){
                                        String varName = parts[1];
                                        String firtVar = parts[2];
                                        String variableName = null;
                                        if (variableName == null){
                                                writer.write("ArrayList<ComplexNumber[]> "+varName+" = QuantumCompilerMethods.quantumInverse(undoingMatrix,undoing"+firtVar+","+varName +");\u005cn");
                                        }
                                        else{
                                                writer.write(varName+" = QuantumCompilerMethods.quantumInverse("+firtVar+","+varName +");\u005cn");
                                        }
                                }
                                else if(parts[0].equals("MEASURE")){
                                        String varName = parts[1];
                                        String firtVar = parts[2];
                                        String variableName = null;
                                        if (variableName == null){
                                                writer.write("double "+firtVar+" = QuantumCompilerMethods.measure("+varName+");\u005cn");
                                        }
                                        else{
                                                writer.write(firtVar+" = QuantumCompilerMethods.measure("+varName+");\u005cn");
                                        }
                                }




                                counter++;
                        }

                        writer.write("}\u005cn"); //Cerrar Main
                        writer.write("}"); //Cerrar Clase
                        b.close();
                        writer.close();
                        System.out.println("String Accepted");

                }catch (ParseException e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }

  static final public void Start() throws ParseException {
    jj_consume_token(INIT);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      RegisterSize();
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    jj_consume_token(0);
  }

  static final public void Find() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
      Register();
      break;
    case APP:
      Apply();
      break;
    case SEL:
      Select();
      break;
    case CON:
      Concatenate();
      break;
    case TEN:
      Tensor();
      break;
    case INV:
      Inverse();
      break;
    case MEAS:
      Measure();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static final public void Apply() throws ParseException {
    jj_consume_token(APP);
    Gate();
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[3] = jj_gen;
      ;
    }
  }

  static final public void Register() throws ParseException {
    jj_consume_token(INIT);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACKET:
      RegisterSize();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[5] = jj_gen;
      ;
    }
  }

  static final public void RegisterSize() throws ParseException {
    jj_consume_token(LBRACKET);
    jj_consume_token(QUBIT);
    jj_consume_token(RBRACKET);
  }

  static final public void Select() throws ParseException {
    jj_consume_token(SEL);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(NUMBER);
    jj_consume_token(TWODOT);
    jj_consume_token(NUMBER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[6] = jj_gen;
      ;
    }
  }

  static final public void Concatenate() throws ParseException {
    jj_consume_token(CON);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
  }

  static final public void Tensor() throws ParseException {
    jj_consume_token(TEN);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
  }

  static final public void Inverse() throws ParseException {
    jj_consume_token(INV);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
  }

  static final public void Measure() throws ParseException {
    jj_consume_token(MEAS);
    jj_consume_token(IDENTIFIER);
    jj_consume_token(IDENTIFIER);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INIT:
    case APP:
    case SEL:
    case CON:
    case TEN:
    case INV:
    case MEAS:
      Find();
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
  }

  static final public void Gate() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case PHASE:
      jj_consume_token(PHASE);
      break;
    case INDEN:
      jj_consume_token(INDEN);
      break;
    case CNOT:
      jj_consume_token(CNOT);
      break;
    case NOT:
      jj_consume_token(NOT);
      break;
    case HADAMARD:
      jj_consume_token(HADAMARD);
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public QuantumAssemblyTokenManager token_source;
  static SimpleCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[12];
  static private int[] jj_la1_0;
  static {
      jj_la1_init_0();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x20000,0x1fc00,0x1fc00,0x1fc00,0x20000,0x1fc00,0x1fc00,0x1fc00,0x1fc00,0x1fc00,0x1fc00,0x3e0,};
   }

  /** Constructor with InputStream. */
  public QuantumAssembly(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QuantumAssembly(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new QuantumAssemblyTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public QuantumAssembly(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new QuantumAssemblyTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public QuantumAssembly(QuantumAssemblyTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(QuantumAssemblyTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 12; i++) jj_la1[i] = -1;
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[28];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 12; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 28; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

}
